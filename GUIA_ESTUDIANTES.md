# Gu√≠a del Proyecto para Estudiantes - Backend Avisos de Empleo

## üìö Introducci√≥n

Este documento explica el proyecto de backend para una aplicaci√≥n de avisos de empleo, dise√±ado para ayudarte a comprender c√≥mo funciona una API REST moderna con Node.js, Express y PostgreSQL.

## üéØ ¬øQu√© es este proyecto?

Es un backend (servidor) que permite:
- Registrar usuarios y autenticarlos
- Publicar avisos de empleo
- Gestionar informaci√≥n de empresas
- Todo esto mediante una API REST que puede ser consumida por un frontend

## üèóÔ∏è Arquitectura del Proyecto

### Patr√≥n MVC (Model-View-Controller)

Este proyecto usa una arquitectura MVC adaptada para APIs:

```
Cliente (Frontend)
    ‚Üì
Rutas (Routes) ‚Üí Define qu√© URL responde a qu√© acci√≥n
    ‚Üì
Controladores (Controllers) ‚Üí L√≥gica de negocio
    ‚Üì
Modelos (Models) ‚Üí Interacci√≥n con la base de datos
    ‚Üì
Base de Datos (PostgreSQL)
```

### Estructura de Carpetas Explicada

```
src/
‚îú‚îÄ‚îÄ config/          ‚Üí Configuraciones (conexi√≥n a BD, etc.)
‚îú‚îÄ‚îÄ controllers/     ‚Üí L√≥gica de negocio (qu√© hacer con cada petici√≥n)
‚îú‚îÄ‚îÄ middlewares/     ‚Üí Funciones que se ejecutan antes de los controladores
‚îú‚îÄ‚îÄ models/          ‚Üí Interacci√≥n con la base de datos
‚îú‚îÄ‚îÄ routes/          ‚Üí Definici√≥n de endpoints (URLs)
‚îî‚îÄ‚îÄ index.js         ‚Üí Punto de entrada (arranca el servidor)
```

## üìñ Conceptos Clave

### 1. API REST

**REST** = Representational State Transfer

Es un estilo de arquitectura para dise√±ar APIs. Usa los m√©todos HTTP:
- **GET**: Obtener datos
- **POST**: Crear datos
- **PUT**: Actualizar datos
- **DELETE**: Eliminar datos

**Ejemplo:**
```
GET /api/avisos        ‚Üí Obtener todos los avisos
GET /api/avisos/1      ‚Üí Obtener el aviso con ID 1
POST /api/avisos       ‚Üí Crear un nuevo aviso
PUT /api/avisos/1      ‚Üí Actualizar el aviso con ID 1
DELETE /api/avisos/1   ‚Üí Eliminar el aviso con ID 1
```

### 2. Middleware

Un middleware es una funci√≥n que se ejecuta **entre** la petici√≥n y la respuesta.

```javascript
// Ejemplo simple de middleware
const middleware = (req, res, next) => {
  console.log('Petici√≥n recibida');
  next(); // Pasar al siguiente middleware o controlador
};
```

**Usos comunes:**
- Verificar autenticaci√≥n (¬øel usuario tiene token v√°lido?)
- Validar datos (¬øel email tiene formato correcto?)
- Logging (registrar peticiones)
- Manejo de errores

### 3. JWT (JSON Web Token)

Es un sistema de autenticaci√≥n **sin estado** (stateless).

**¬øC√≥mo funciona?**

1. Usuario se registra/inicia sesi√≥n
2. Servidor genera un token JWT firmado
3. Cliente guarda el token
4. Cliente env√≠a el token en cada petici√≥n
5. Servidor verifica el token

```javascript
// Ejemplo de token JWT
const token = jwt.sign(
  { userId: 1, email: 'user@example.com' }, // Datos (payload)
  'clave_secreta',                           // Clave para firmar
  { expiresIn: '24h' }                       // Opciones
);
```

**Estructura de un JWT:**
```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOjF9.SflKxwRJ...
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Header ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ Payload ‚îÄ‚îÄ‚îò ‚îî‚îÄ Signature ‚îÄ‚îò
```

### 4. Hash de Contrase√±as

**¬°NUNCA guardes contrase√±as en texto plano!**

Usamos `bcryptjs` para encriptar contrase√±as:

```javascript
// Encriptar
const hash = await bcrypt.hash('miContrase√±a', 10);
// Resultado: $2a$10$N9qo8uLOickgx2ZMRZoMyeIjZAgcfl7p92ldGxad68LJZdL...

// Verificar
const esValida = await bcrypt.compare('miContrase√±a', hash);
// true o false
```

## üîç Recorrido por el C√≥digo

### 1. Punto de Entrada: `index.js`

```javascript
import express from 'express';
import cors from 'cors';

const app = express(); // Crear aplicaci√≥n Express

// Middlewares globales
app.use(cors());              // Permitir peticiones desde otros dominios
app.use(express.json());      // Parsear JSON del body

// Rutas
app.use('/api/avisos', avisoRoutes);
app.use('/api/auth', authRoutes);

// Iniciar servidor
app.listen(3000, () => {
  console.log('Servidor en puerto 3000');
});
```

### 2. Rutas: `authRoutes.js`

Las rutas conectan URLs con controladores:

```javascript
import express from 'express';
import { authController } from '../controllers/authController.js';

const router = express.Router();

// POST /api/auth/register ‚Üí authController.register
router.post('/register', authController.register);
router.post('/login', authController.login);

export default router;
```

### 3. Controladores: `authController.js`

Contienen la l√≥gica de negocio:

```javascript
export const authController = {
  async register(req, res, next) {
    try {
      const { email, password } = req.body;

      // Validar datos
      if (!email || !password) {
        return res.status(400).json({
          message: 'Email y password requeridos'
        });
      }

      // Verificar si existe
      const exists = await userModel.exists(email);
      if (exists) {
        return res.status(409).json({
          message: 'Usuario ya existe'
        });
      }

      // Crear usuario
      const user = await userModel.create({ email, password });

      // Generar token
      const token = jwt.sign(
        { userId: user.id, email: user.email },
        JWT_SECRET,
        { expiresIn: '24h' }
      );

      // Responder
      res.status(201).json({
        success: true,
        data: { user, token }
      });

    } catch (error) {
      next(error); // Pasar error al middleware de errores
    }
  }
};
```

### 4. Modelos: `userModel.js`

Interact√∫an con la base de datos:

```javascript
import bcrypt from 'bcryptjs';
import sql from '../config/database.js';

export const userModel = {
  // Crear usuario
  async create(userData) {
    const { email, password } = userData;

    // Encriptar contrase√±a
    const passwordHash = await bcrypt.hash(password, 10);

    // Insertar en BD y retornar el registro creado
    const [user] = await sql`
      INSERT INTO usuarios (email, password_hash)
      VALUES (${email}, ${passwordHash})
      RETURNING id, email, created_at
    `;

    return user;
  },

  // Buscar por email
  async findByEmail(email) {
    const [user] = await sql`
      SELECT * FROM usuarios WHERE email = ${email}
    `;
    return user;
  }
};
```

### 5. Middlewares: `auth.js`

Verifican autenticaci√≥n:

```javascript
export const authenticateToken = (req, res, next) => {
  // Obtener token del header
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1]; // "Bearer TOKEN"

  if (!token) {
    return res.status(401).json({
      message: 'Token requerido'
    });
  }

  // Verificar token
  jwt.verify(token, JWT_SECRET, (err, user) => {
    if (err) {
      return res.status(403).json({
        message: 'Token inv√°lido'
      });
    }

    // Agregar usuario al request
    req.user = user;
    next(); // Continuar al controlador
  });
};
```

**Uso en rutas:**

```javascript
// Ruta protegida - requiere autenticaci√≥n
router.post('/avisos', authenticateToken, avisoController.create);
//                     ‚Üë Middleware que verifica el token
```

## üîÑ Flujo Completo de una Petici√≥n

### Ejemplo: Crear un aviso de empleo

```
1. Cliente env√≠a petici√≥n:
   POST /api/avisos
   Headers: { Authorization: "Bearer eyJhbG..." }
   Body: { titulo: "Developer", descripcion: "..." }

2. Express recibe la petici√≥n
   ‚Üì
3. Middleware CORS permite la petici√≥n
   ‚Üì
4. express.json() parsea el body
   ‚Üì
5. Router identifica: POST /api/avisos ‚Üí avisoRoutes
   ‚Üì
6. Middleware authenticateToken verifica el token JWT
   ‚Üì
7. Si el token es v√°lido, contin√∫a al controlador
   ‚Üì
8. avisoController.create procesa la petici√≥n
   ‚Üì
9. avisoModel.create inserta en la base de datos
   ‚Üì
10. Controlador env√≠a respuesta al cliente
    ‚Üì
11. Cliente recibe: { success: true, data: { ... } }
```

## üóÑÔ∏è Base de Datos

### Conexi√≥n: `database.js`

```javascript
import postgres from 'postgres';

// Crear conexi√≥n usando la URL de entorno
const sql = postgres(process.env.DATABASE_URL);

export default sql;
```

### Consultas SQL con postgres.js

```javascript
// Insertar
const [user] = await sql`
  INSERT INTO usuarios (email, password_hash)
  VALUES (${email}, ${hash})
  RETURNING *
`;

// Consultar
const users = await sql`
  SELECT * FROM usuarios WHERE email = ${email}
`;

// Actualizar
await sql`
  UPDATE usuarios
  SET email = ${newEmail}
  WHERE id = ${userId}
`;

// Eliminar
await sql`
  DELETE FROM usuarios WHERE id = ${userId}
`;
```

## üõ°Ô∏è Seguridad

### Buenas Pr√°cticas Implementadas

1. **Contrase√±as encriptadas**: Usamos bcryptjs
2. **Variables de entorno**: Datos sensibles en `.env`
3. **JWT**: Autenticaci√≥n sin guardar sesiones
4. **Validaci√≥n de datos**: Verificamos inputs antes de procesar
5. **Manejo de errores**: No exponemos detalles internos

### Variables de Entorno (`.env`)

```env
# NUNCA subir este archivo a Git
DATABASE_URL=postgresql://user:pass@host:5432/db
JWT_SECRET=clave_super_secreta_cambiar_en_produccion
JWT_EXPIRATION=24h
PORT=3000
```

## üß™ Probando la API

### Con cURL

```bash
# Registrar usuario
curl -X POST http://localhost:3000/api/auth/register \
  -H "Content-Type: application/json" \
  -d '{"email":"test@test.com","password":"123456"}'

# Login
curl -X POST http://localhost:3000/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{"email":"test@test.com","password":"123456"}'

# Crear aviso (con token)
curl -X POST http://localhost:3000/api/avisos \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer eyJhbG..." \
  -d '{"titulo":"Developer","empresa_id":1}'
```

### Con Postman o Thunder Client

1. Crear una petici√≥n POST a `http://localhost:3000/api/auth/login`
2. En Body ‚Üí JSON: `{"email":"test@test.com","password":"123456"}`
3. Enviar y copiar el token de la respuesta
4. Para rutas protegidas, agregar header: `Authorization: Bearer <token>`

## üìö Conceptos de Node.js Usados

### 1. M√≥dulos ES6

```javascript
// Exportar
export const authController = { ... };
export default router;

// Importar
import express from 'express';
import { authController } from './controllers/authController.js';
```

### 2. Async/Await

```javascript
// Manejo de operaciones as√≠ncronas
async function obtenerUsuario() {
  const user = await userModel.findByEmail('test@test.com');
  return user;
}
```

### 3. Destructuring

```javascript
// Extraer propiedades de objetos
const { email, password } = req.body;

// En lugar de:
const email = req.body.email;
const password = req.body.password;
```

### 4. Template Literals

```javascript
// Con postgres.js usamos tagged templates
const users = await sql`SELECT * FROM usuarios WHERE id = ${userId}`;
```

## üöÄ Comandos √ötiles

```bash
# Instalar dependencias
npm install

# Iniciar en desarrollo (con auto-reload)
npm run dev

# Iniciar en producci√≥n
npm start

# Ver logs del servidor
# El servidor muestra en consola cada petici√≥n recibida
```

## üìù Ejercicios Propuestos

### Nivel B√°sico

1. Agregar un endpoint GET `/api/auth/me` que retorne el usuario actual (usando el token)
2. Agregar validaci√≥n de email (formato v√°lido)
3. Agregar un campo `nombre` al registro de usuarios

### Nivel Intermedio

4. Implementar un endpoint para cambiar la contrase√±a
5. Agregar paginaci√≥n a GET `/api/avisos` (limit y offset)
6. Implementar b√∫squeda de avisos por t√≠tulo

### Nivel Avanzado

7. Implementar refresh tokens (tokens que expiran y se renuevan)
8. Agregar roles de usuario (admin, empresa, usuario)
9. Implementar upload de im√°genes para logos de empresas

## üîó Recursos Adicionales

- [Express.js Docs](https://expressjs.com/)
- [JWT.io](https://jwt.io/) - Decodificar y entender JWTs
- [Postgres.js Docs](https://github.com/porsager/postgres)
- [REST API Best Practices](https://stackoverflow.blog/2020/03/02/best-practices-for-rest-api-design/)

## ‚ùì Preguntas Frecuentes

**P: ¬øPor qu√© usamos JWT en lugar de sesiones?**
R: JWT es stateless (sin estado), perfecto para APIs que pueden ser consumidas por m√∫ltiples clientes (web, m√≥vil, etc.). No necesitamos guardar sesiones en el servidor.

**P: ¬øQu√© es el salt en bcrypt?**
R: Es un valor aleatorio que se agrega a la contrase√±a antes de encriptarla. Hace que dos usuarios con la misma contrase√±a tengan hashes diferentes.

**P: ¬øPor qu√© separar en capas (routes, controllers, models)?**
R: Separaci√≥n de responsabilidades. Facilita el mantenimiento, testing y escalabilidad del c√≥digo.

**P: ¬øQu√© es `next()` en los middlewares?**
R: Es una funci√≥n que pasa el control al siguiente middleware o controlador en la cadena.

**P: ¬øPor qu√© usar variables de entorno?**
R: Para separar la configuraci√≥n del c√≥digo. Diferentes ambientes (desarrollo, producci√≥n) pueden tener diferentes configuraciones sin cambiar el c√≥digo.

## üéì Conclusi√≥n

Este proyecto te ense√±a:
- Arquitectura de APIs REST
- Autenticaci√≥n moderna con JWT
- Seguridad b√°sica (encriptaci√≥n, validaci√≥n)
- Interacci√≥n con bases de datos
- Buenas pr√°cticas de Node.js

¬°Experimenta, rompe cosas, aprende! üí™
